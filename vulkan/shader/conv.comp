#version 450
#define LOCAL_SZ_X 256
layout(push_constant) uniform pushBlock {
    int IN_H;
    int IN_W;
    int OUT_H;
    int OUT_W;
    int STRIDE_H;
    int STRIDE_W;
    int DILATION_H;
    int DILATION_W;
    int PAD_H;
    int PAD_W;
    int FILTER_H;
    int FILTER_W;
    int CHANNELS;
    int BATCH;
    int HAS_BIAS;
    int M;
    int K;
    int N;
    int TAIL_M;
    int DEPTH_MULTIPLIER;
    int ACTIVATION;
    int BASIC_SHADER_BATCH_IDX;
    int BASIC_SHADER_PARTITION_IDX;
    int BASIC_SHADER_PARTITION_SIZE;
} p;

#define ACTIVATION_FUNCTION(x)   \
{                                \
    if (ACTIVATION == 1)         \
      x = max(x, 0.0);           \
    else if (ACTIVATION == 2)    \
      x = clamp(x, -1.0, 1.0);   \
    else if (ACTIVATION == 3)    \
      x = clamp(x, 0.0, 6.0);    \
}

layout(binding = 0) readonly buffer Input0{
    float image_data[];
};
layout(binding = 1) readonly buffer Input1{
    float weight_data[];
};
layout(binding = 2) readonly buffer Input2 {
    float bias_data[];
};
layout(binding = 3) writeonly buffer Output{
    float convolved_image_data[];
};

// todo: should be passed from configuration ...
layout(local_size_x = 1, local_size_y = 16, local_size_z = 1) in;

void main()
{
    int gx = int(gl_GlobalInvocationID.x);
    int gy = int(gl_GlobalInvocationID.y);
    int gz = int(gl_GlobalInvocationID.z);

    if (gx < p.M && gy < p.N && gz < p.BATCH)
    {
        float sum = 0.0f;
        int output_y = gy / p.OUT_W;
        int output_x = gy % p.OUT_W;
        int org_y = output_y * p.STRIDE_H - p.PAD_H;
        int org_x = output_x * p.STRIDE_W - p.PAD_W;
        int weight_off = gx * p.K;
        // int input_off = gz * p.IN_H * IN_W * CHANNELS + (org_y * IN_W + org_x);
        int image_offset  = gz * p.IN_H * p.IN_W * p.CHANNELS;
        int output_offset = gz * p.M * p.N;
        int input_off = image_offset + (org_y * p.IN_W + org_x) * p.CHANNELS;

        for (int y = 0; y < p.FILTER_H; y++)
        {
            for (int x = 0; y < p.FILTER_W; x++)
            {
                if (org_y + y >= 0 && org_y + y < p.IN_H && org_x + x >= 0 && org_x + x < p.IN_W)
                {
                    for(int c = 0; c < p.CHANNELS; c++)
                    {
                       sum += image_data[input_off + c] * weight_data[weight_off + c];
                    }
                }
                input_off += p.CHANNELS;
                weight_off += p.CHANNELS;
            }
            input_off += p.IN_W * p.CHANNELS - p.CHANNELS * p.FILTER_W;
        }

        int offset = output_offset + gy * p.N + gx;
        // todo: add activation
        convolved_image_data[offset] = sum + bias_data[gx];
    }
}
