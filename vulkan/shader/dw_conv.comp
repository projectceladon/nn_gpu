#version 450
#define LOCAL_SZ_X 256

layout(push_constant) uniform pushBlock {
    int in_h;
    int in_w;
    int out_h;
    int out_w;
    int stride_h;
    int stride_w;
    int dilation_h;
    int dilation_w;
    int pad_h;
    int pad_w;
    int filter_h;
    int filter_w;
    int channels;
    int has_bias;
    int M;
    int K;
    int N;
    int depth_multiplier;
    int activation;
} p;

layout(binding = 0) readonly buffer Input0{
    float in_buffer[];
};
layout(binding = 1) readonly buffer Input2{
    float weight_data[];
};
layout(binding = 2) readonly buffer Input1 {
    float bias_data[];
};
layout(binding = 3) writeonly buffer Output{
    float out_buffer[];
};

// todo: from config.
layout(local_size_x = 1, local_size_y = 1, local_size_z = 16) in;

void main()
{
    int gx  = int(gl_GlobalInvocationID.x);
    int gy  = int(gl_GlobalInvocationID.y);
    int inz = int(gl_GlobalInvocationID.z);
    int gz  = inz * p.depth_multiplier;

    if (gx < p.out_w && gy < p.out_h)
    {
        float sum[1];  // todo: array size got from p.depth_multiplier
        for (int outz = 0; outz < p.depth_multiplier; outz++)
        {
            sum[outz] = 0.0f;
        }

        int org_y = gy * p.stride_h - p.pad_h;
        int org_x = gx * p.stride_w - p.pad_w;

        int kernel_offset = 0;
        int image_offset = 0;
        int bias_offset = 0;
        int weight_off = kernel_offset + gz;
        int bias_off = bias_offset + gz;
        int input_off = image_offset + (org_y * p.in_w + org_x) * p.channels + inz;

        for (int y = 0; y < p.filter_h; y++)
        {
            for(int x = 0; x < p.filter_w; x++)
            {
                if (org_y + y * p.dilation_h >= 0 && org_y + y * p.dilation_h < p.in_h && org_x + x * p.dilation_w >= 0 \
                   && org_x + x * p.dilation_w < p.in_w)
                {
                    for (int outz =0; outz < p.depth_multiplier; outz++)
                    {
                        sum[outz] += in_buffer[input_off] * weight_data[weight_off + outz];
                    }
                }
                input_off += p.dilation_w * p.channels;
                weight_off += p.channels * p.depth_multiplier;
            }
            input_off += p.in_w * p.dilation_h * p.channels - p.dilation_w * p.channels * p.filter_w;
        }

        int out_buffer_offset = 0;
        if (p.has_bias == 1)
        {
            for (int outz = 0; outz < p.depth_multiplier; outz++)
            {
                if (gz + outz < p.N)
                {
                    int offset = out_buffer_offset + (gy * p.out_w  + gx) * p.N + gz + outz;
                    out_buffer[offset] = sum[outz] + bias_data[bias_off +outz]; // TODO: add ACTIVATION_FUNCTION
                }
            }
        }
        else
        {
            for (int outz = 0; outz < p.depth_multiplier; outz++)
            {
                if (gz + outz < p.N)
                {
                    int offset = out_buffer_offset + (gy * p.out_w + gx) * p.N + gz + outz;
                    out_buffer[offset] = sum[outz];  // todo: add ACTIVATION_FUNCTION
                }
            }
        }
    }
}
